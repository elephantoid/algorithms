# 그리디 알고리즘(탐욕법)
현재 상황에서 지금 당장 좋은 것만 고르는 방법
일반적인 그리디 알고리즘은 문제를 풀기위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구
그리디 해법은 정당성 분석이 중요합니다
	단순히 최선의 선택을 반복적으로 해도 최적의 해를 구할 수 있는 검토
일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많습니다
코딩 테스트에서는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제됩니다

## <문제1: 거스름 돈>
카운터에 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정합니다.
손님에게 거슬러 주어야 할 돈이 N원일 때 거슬러 주어야 할 동전의 최소 개수를 구하시오.

<문제해결 아이디어>
최적의 해를 빠르게 구하기 위해서는 가장 큰 화폐 단위부터 돈을 거슬러 주면 됩니다.
가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 최적의 해를 보장할 수 있다.
```
#e.g
N=1260
count=0
charge=[500,100,50,10]

for coin in charge:
	count+= N//coin
	N%=coin
print(count)
```
화폐의 종류가 K라고 할 때, 시간 복잡도는 O(K)
금액과는 무관하며, 동전의 종류에 따라 달라짐

## <문제2: 1이 될때까지> 
어떠한 수 N이 1이 될 때까지 두과정 중 하나를 반복적으로 선택하여 수행
단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있습니다.
1. N에서 1을 뺍니다
2. N을 K로 나눕니다.
<문제1:정당성 분석>
최대한 많이 나누는 작업이 최적의 해를 항상 보장할 수 있을까?
N이 아무리 큰 수여도, K로 계속 나눈다면 기하급수적으로 빠르게 줄일 수 있다.
K가 2이상이기만 하면 K로 나누는것이 1을 빼는 것 보다 항상 빠르게 N을 줄일 수 있다.

## <문제3: 곱하기 혹은 더하기>
각 자리가 숫자(0~9)로 이루어진 문자열 S가 주어졌을때, 왼쪽부터 오른쪽으로 하나씩
모든 숫자를 확인하며 숫자 사이에 'x' 혹은 '+' 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성
단, +보다 *를 먼저 계산하는 일반식과 달리, 모든 연산은 왼쪽에서부터 순서대로
```
# case 1
input= 82984
output= 576 
# case 2
input= 567
output= 210
```
## <문제4: 모험가 길드>
마을에 모험가가 N명 있습니다. N명의 모험가의 대상으로 '공포도'를 측정
'공포도'가 높은 모험가는 쉽게 공포를 느낌 위기대처능력이 떨어짐
공포토가 X인 모험가는 반드지 X명이상으로 구성한 모험가 그룹에 참여
N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹 수의 최댓값을 구하여라
```
#e.g
첫째 줄 모험가수 N명
둘째 줄 각 모험가의 공포도
N=5
공포도=2, 3, 1, 2, 2
group1= 1, 2, 3
group2= 2, 2
max_group=2
#몇 명의 모험가는 마을에 그대로 남아 있어도 되기 때문에, 모든 모험가를 특정한 그룹에 넣을 필요는 없다.
```

